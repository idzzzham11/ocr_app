import 'dart:io';
import 'dart:convert';
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
// import 'package:file_picker/file_picker.dart';
// import 'package:image/image.dart' as img;
// import 'package:syncfusion_flutter_pdf/pdf.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Document Text Extractor',
      theme: ThemeData(
        primarySwatch: Colors.deepPurple,
        useMaterial3: true,
      ),
      home: const MyHomePage(title: 'Document Text Extractor'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class DocumentData {
  final String? companyName;
  final String? location;
  final String? contactInfo;
  final String? vehicleNumber;
  final String? driverIc;
  final String? driverName;
  final String? company;
  final String? trailerNumber;
  final String? deliveryNote;
  final String? entryDate;
  final String? entryTime;
  final String? exitDate;
  final String? exitTime;
  final Map<String, String> additionalFields;

  DocumentData({
    this.companyName,
    this.location,
    this.contactInfo,
    this.vehicleNumber,
    this.driverIc,
    this.driverName,
    this.company,
    this.trailerNumber,
    this.deliveryNote,
    this.entryDate,
    this.entryTime,
    this.exitDate,
    this.exitTime,
    this.additionalFields = const {},
  });

  // Convert to JSON map
  Map<String, dynamic> toJson() {
    return {
      'companyName': companyName,
      'location': location,
      'contactInfo': contactInfo,
      'vehicleNumber': vehicleNumber,
      'driverIc': driverIc,
      'driverName': driverName,
      'company': company,
      'trailerNumber': trailerNumber,
      'deliveryNote': deliveryNote,
      'entryDate': entryDate,
      'entryTime': entryTime,
      'exitDate': exitDate,
      'exitTime': exitTime,
      'additionalFields': additionalFields,
    };
  }
}

class _MyHomePageState extends State<MyHomePage> {
  File? _file;
  String? _extractedText;
  bool _isImage = false;
  String? _fileName;
  bool _isProcessing = false;
  DocumentData? _documentData;
  
  void _handlePickedImage(XFile pickedFile) async {
    setState(() {
      _isProcessing = true;
      _file = File(pickedFile.path);
      _fileName = pickedFile.name;
      _isImage = true;
      _extractedText = null;
    });
    
    await _extractTextFromImage(_file!);
    
    setState(() {
      _isProcessing = false;
    });
  }

  Future<void> _pickImage() async {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Wrap(
            children: <Widget>[
              ListTile(
                leading: const Icon(Icons.photo_library),
                title: const Text('Gallery'),
                onTap: () async {
                  Navigator.of(context).pop();
                  final pickedFile = await ImagePicker().pickImage(
                    source: ImageSource.gallery,
                    imageQuality: 100,
                  );
                  if (pickedFile != null) {
                    _handlePickedImage(pickedFile);
                  }
                },
              ),
              ListTile(
                leading: const Icon(Icons.camera_alt),
                title: const Text('Camera'),
                onTap: () async {
                  Navigator.of(context).pop();
                  final pickedFile = await ImagePicker().pickImage(
                    source: ImageSource.camera,
                    imageQuality: 100,
                  );
                  if (pickedFile != null) {
                    _handlePickedImage(pickedFile);
                  }
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Future<void> _extractTextFromImage(File imageFile) async {
  final inputImage = InputImage.fromFilePath(imageFile.path);
  final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
  
  try {
    // Print debug info first
    print("Processing image: ${imageFile.path}");
    
    final recognizedText = await textRecognizer.processImage(inputImage);
    
    // Log raw text for debugging
    // print("Raw OCR text:");
    // print(recognizedText.text);
    
    // Process the recognized text
    _processExtractedText(recognizedText.text);
  } catch (e) {
    setState(() {
      _extractedText = "Error extracting text: ${e.toString()}";
    });
    print("Error in text extraction: $e");
  } finally {
    textRecognizer.close();
  }
}

  // Future<void> _pickPDF() async {
  //   final result = await FilePicker.platform.pickFiles(
  //     type: FileType.custom, 
  //     allowedExtensions: ['pdf']
  //   );
    
  //   if (result != null && result.files.single.path != null) {
  //     setState(() {
  //       _isProcessing = true;
  //       _file = File(result.files.single.path!);
  //       _fileName = result.files.single.name;
  //       _isImage = false;
  //       _extractedText = null;
  //     });
      
  //     await _extractTextFromPDF(_file!);
      
  //     setState(() {
  //       _isProcessing = false;
  //     });
  //   }
  // }

  // Future<void> _extractTextFromPDF(File pdfFile) async {
  //   try {
  //     final bytes = await pdfFile.readAsBytes();
  //     final document = PdfDocument(inputBytes: bytes);

  //     // Extract raw text from all pages
  //     String rawText = '';
  //     for (int i = 0; i < document.pages.count; i++) {
  //       rawText += PdfTextExtractor(document).extractText(startPageIndex: i, endPageIndex: i);
  //     }
  //     document.dispose();

  //     // Process the extracted text
  //     _processExtractedText(rawText);
  //   } catch (e) {
  //     setState(() {
  //       _extractedText = "Error extracting text from PDF: ${e.toString()}";
  //     });
  //   }
  // }

List<String> preprocessOcrLines(List<String> rawLines) {
  // Log raw input
  print("==== RAW OCR LINES ====");
  for (int i = 0; i < rawLines.length; i++) {
    print('[$i] ${rawLines[i]}');
  }
  
  // First, identify any lines that contain field:value pairs
  List<Map<String, dynamic>> structuredLines = [];
  
  for (int i = 0; i < rawLines.length; i++) {
    String line = rawLines[i];
    
    // Check if this is a field:value pair
    if (line.contains(':')) {
      int colonIndex = line.indexOf(':');
      String field = line.substring(0, colonIndex).trim();
      String value = line.substring(colonIndex + 1).trim();
      
      structuredLines.add({
        'lineIndex': i,
        'type': 'field',
        'original': line,
        'field': field,
        'value': value,
        'colonPos': colonIndex,
      });
    } else {
      // If not a field:value pair, it could be just a field name or just a value
      bool isLikelyFieldName = isFieldNamePattern(line);
      
      structuredLines.add({
        'lineIndex': i,
        'type': isLikelyFieldName ? 'potentialField' : 'text',
        'original': line,
      });
    }
  }
  
  // Process structured lines to improve field-value associations
  List<String> improved = [];
  
  // First, add all complete field:value pairs
  for (var item in structuredLines) {
    if (item['type'] == 'field' && item['value'].isNotEmpty) {
      improved.add('${item['field']}: ${item['value']}');
    }
  }
  
  // Now handle potential field names without values
  for (int i = 0; i < structuredLines.length; i++) {
    var current = structuredLines[i];
    
    // If this is a field without a value, try to find a matching value
    if (current['type'] == 'field' && current['value'].isEmpty) {
      String fieldName = current['field'];
      bool valueFound = false;
      
      // Look ahead at the next line to find a potential value
      if (i + 1 < structuredLines.length) {
        var next = structuredLines[i + 1];
        
        // If next item is plain text (not a field), it might be our value
        if (next['type'] == 'text') {
          improved.add('${fieldName}: ${next['original']}');
          valueFound = true;
          // Skip this item in the next iteration since we used it
          structuredLines[i + 1]['processed'] = true;
        }
      }
      
      // If no value found using the next line, try spatial matching
      if (!valueFound) {
        // Find values that might match based on column position
        int colonPos = current['colonPos'];
        
        // Look for values with similar column position
        for (int j = 0; j < structuredLines.length; j++) {
          if (i == j || structuredLines[j]['processed'] == true) continue;
          
          var other = structuredLines[j];
          
          // If this is a field:value pair with a value and similar column position
          if (other['type'] == 'field' && 
              other['value'].isNotEmpty && 
              other['colonPos'] != null &&
              (other['colonPos'] - colonPos).abs() < 5) {
            
            improved.add('${fieldName}: ${other['value']}');
            valueFound = true;
            break;
          }
        }
      }
      
      // If still no value found, add as field name without value
      if (!valueFound) {
        improved.add('${fieldName}: Not Detected');
      }
    }
  }
  
  // Process potential field names (lines that look like field names but don't have colons)
  for (int i = 0; i < structuredLines.length; i++) {
    var current = structuredLines[i];
    
    if (current['type'] == 'potentialField' && current['processed'] != true) {
      String potentialField = current['original'];
      bool valueFound = false;
      
      // Look at the next line to find a potential value
      if (i + 1 < structuredLines.length) {
        var next = structuredLines[i + 1];
        
        // If next item is plain text (not a field), it might be our value
        if (next['type'] == 'text' && next['processed'] != true) {
          improved.add('${potentialField}: ${next['original']}');
          valueFound = true;
          // Mark as processed
          structuredLines[i + 1]['processed'] = true;
        }
      }
      
      // If no value found, add field without value
      if (!valueFound) {
        // Only add if it's a known field pattern
        if (isKnownFieldPattern(potentialField)) {
          improved.add('${potentialField}: Not Detected');
        } else {
          // Otherwise just add the text as is
          improved.add(potentialField);
        }
      }
    }
    // Add remaining text lines that haven't been processed
    else if (current['type'] == 'text' && current['processed'] != true) {
      improved.add(current['original']);
    }
  }
  
  // Add known fields that might be missing
  List<String> requiredFields = [
    'NOMBOR KENDERAAN',
    'K.P. PEMANDU',
    'NAMA PEMANDU',
    'SYARIKAT',
  ];

  for (var field in requiredFields) {
    bool found = improved.any((line) => 
        line.toUpperCase().startsWith(field.toUpperCase() + ':'));
    if (!found) {
      improved.add('$field: Not Detected');
    }
  }
  
  // Log the preprocessed result
  print("==== PREPROCESSED OCR LINES ====");
  for (int i = 0; i < improved.length; i++) {
    print('[$i] ${improved[i]}');
  }
  
  return improved;
}

// Check if a string matches common field name patterns
bool isFieldNamePattern(String text) {
  // Common field name patterns
  List<String> fieldPatterns = [
    'NOMBOR', 'NAMA', 'K.P.', 'SYARIKAT', 'TARIKH', 'MASA', 
    'KOD', 'SUB', 'TRAILER', 'NOTA', 'DRIVER', 'COMPANY',
    'ENTRY', 'EXIT', 'DATE', 'TIME', 'VEHICLE'
  ];
  
  for (String pattern in fieldPatterns) {
    if (text.toUpperCase().contains(pattern)) {
      return true;
    }
  }
  
  return false;
}

// Check if a string is a known important field name
bool isKnownFieldPattern(String text) {
  // List of known important field names
  List<String> knownFields = [
    'NOMBOR KENDERAAN', 'NO. KENDERAAN', 'NO KENDERAAN',
    'K.P. PEMANDU', 'NO. K/P', 'IC NO', 'K.P PEMANDU',
    'NAMA PEMANDU', 'PEMANDU',
    'SYARIKAT', 'COMPANY',
    'NOMBOR TRAILER', 'NO. TRAILER', 'TRAILER',
    'NOTA HANTARAN', 'ARAHAN ANGKUT',
    'TARIKH MASUK', 'ENTRY DATE',
    'MASA MASUK', 'ENTRY TIME',
    'TARIKH KELUAR', 'EXIT DATE',
    'MASA KELUAR', 'EXIT TIME',
    'MUDA', 'LAMA', 'PERAM', 'DURA', 'MENGKAL', 'KOSONG', 
    'PANJANG', 'BUSUK', 'KOTOR', 'S/TIKUS', 'P/T', 'BAS', 'MENG'
  ];
  
  for (String field in knownFields) {
    if (text.toUpperCase().contains(field)) {
      return true;
    }
  }
  
  return false;
}

Map<String, String> extractKeyFields(List<String> rawLines) {
  Map<String, String> result = {};
  
  // Define the key fields we need to extract with their possible variations
  Map<String, List<String>> keyFieldMappings = {
    'NOMBOR KENDERAAN': ['NOMBOR KENDERAAN', 'NO. KENDERAAN', 'NO KENDERAAN', 'NOMBOR KENDERAAN :'],
    'K.P. PEMANDU': ['K.P. PEMANDU', 'NO. K/P', 'IC NO', 'K.P PEMANDU', 'K.P. PEMANDU :'],
    'NAMA PEMANDU': ['NAMA PEMANDU', 'NAMA PEMANDU :'],
    'SYARIKAT': ['SYARIKAT', 'COMPANY', 'SYARIKAT :'],
    'NOMBOR TRAILER': ['NOMBOR TRAILER', 'NO. TRAILER', 'TRAILER', 'NOMBOR TRAILER :'],
    'NOTA HANTARAN/ARAHAN ANGKUT': ['NOTA HANTARAN/ARAHAN ANGKUT', 'NOTA HANTARAN', 'ARAHAN ANGKUT', 'NOTA HANTARAN :'],
    'TARIKH MASUK': ['TARIKH MASUK', 'ENTRY DATE', 'TARIKH MASUK :'],
    'MASA MASUK': ['MASA MASUK', 'ENTRY TIME', 'MASA MASUK :']
  };
  
  // Initialize all fields to empty string
  keyFieldMappings.keys.forEach((key) {
    result[key] = '';
  });
  
  // First pass: Look for exact field:value patterns
  for (String line in rawLines) {
    for (String field in keyFieldMappings.keys) {
      for (String pattern in keyFieldMappings[field]!) {
        // Case 1: Pattern followed by colon and value
        if (line.toUpperCase().contains(pattern.toUpperCase() + ':')) {
          int startIdx = line.toUpperCase().indexOf(pattern.toUpperCase() + ':');
          int valueStartIdx = startIdx + pattern.length + 1; // +1 for the colon
          
          if (valueStartIdx < line.length) {
            String value = line.substring(valueStartIdx).trim();
            if (value.isNotEmpty) {
              result[field] = value;
              print("Found $field: $value");
              break;
            }
          }
        }
        // Case 2: Pattern and colon are together without space
        else if (line.toUpperCase().contains(pattern.toUpperCase().replaceAll(' :', ':') + ':')) {
          String patternWithColon = pattern.toUpperCase().replaceAll(' :', ':') + ':';
          int startIdx = line.toUpperCase().indexOf(patternWithColon);
          int valueStartIdx = startIdx + patternWithColon.length;
          
          if (valueStartIdx < line.length) {
            String value = line.substring(valueStartIdx).trim();
            if (value.isNotEmpty) {
              result[field] = value;
              print("Found $field (case 2): $value");
              break;
            }
          }
        }
      }
    }
  }
  
  // Second pass: Field-specific enhancements for more accurate extraction
  
  // For Vehicle Number (common patterns like WA, WB, etc.)
  if (result['NOMBOR KENDERAAN']!.isEmpty) {
    for (String line in rawLines) {
      // Malaysian vehicle registration often starts with W, like WA1086P
      if (RegExp(r'W[A-Z][0-9]{3,4}[A-Z]?').hasMatch(line)) {
        result['NOMBOR KENDERAAN'] = RegExp(r'W[A-Z][0-9]{3,4}[A-Z]?').stringMatch(line)!;
        print("Extracted vehicle number from pattern: ${result['NOMBOR KENDERAAN']}");
        break;
      }
    }
  }
  
  // For Driver IC (12-digit Malaysian IC)
  if (result['K.P. PEMANDU']!.isEmpty) {
    for (String line in rawLines) {
      if (RegExp(r'[0-9]{12}').hasMatch(line)) {
        result['K.P. PEMANDU'] = RegExp(r'[0-9]{12}').stringMatch(line)!;
        print("Extracted IC from digits: ${result['K.P. PEMANDU']}");
        break;
      }
    }
  }
  
  // For Driver Name (usually contains BIN/BINTI)
  if (result['NAMA PEMANDU']!.isEmpty) {
    for (String line in rawLines) {
      if ((line.toUpperCase().contains('BIN') || line.toUpperCase().contains('BINTI')) &&
          !line.contains(':')) {
        result['NAMA PEMANDU'] = line.trim();
        print("Extracted name from BIN/BINTI: ${result['NAMA PEMANDU']}");
        break;
      }
    }
  }
  
  // SYARIKAT specific extraction - first try direct match
  if (result['SYARIKAT']!.isEmpty) {
    for (String line in rawLines) {
      if (line.toUpperCase().contains('SYARIKAT') && line.contains(':')) {
        int colonPos = line.indexOf(':');
        if (colonPos >= 0 && colonPos + 1 < line.length) {
          String value = line.substring(colonPos + 1).trim();
          if (value.contains('FELDA JENGKA')) {
            result['SYARIKAT'] = value;
            print("Extracted SYARIKAT directly: ${result['SYARIKAT']}");
            break;
          }
        }
      }
    }
  }
  
  // If SYARIKAT is still empty, try a different approach
  if (result['SYARIKAT']!.isEmpty) {
    // Look for lines containing "FELDA JENGKA 4" that are not part of the address
    for (String line in rawLines) {
      if (line.contains('FELDA JENGKA 4') && 
          !line.contains('PUSAT') && 
          !line.contains('D/A') &&
          !line.contains('Palm Industries')) {
        
        result['SYARIKAT'] = 'FELDA JENGKA 4';
        print("Extracted SYARIKAT from pattern: ${result['SYARIKAT']}");
        break;
      }
    }
  }
  
  // If SYARIKAT is still empty, look for context clues
  if (result['SYARIKAT']!.isEmpty) {
    for (int i = 0; i < rawLines.length; i++) {
      if (rawLines[i].toUpperCase().contains('SYARIKAT')) {
        // Check lines around it for FELDA JENGKA
        int startIdx = math.max(0, i - 1);
        int endIdx = math.min(rawLines.length - 1, i + 2);
        
        for (int j = startIdx; j <= endIdx; j++) {
          if (rawLines[j].contains('FELDA JENGKA')) {
            result['SYARIKAT'] = 'FELDA JENGKA 4';
            print("Extracted SYARIKAT from context: ${result['SYARIKAT']}");
            break;
          }
        }
      }
    }
  }
  
  // Last resort for SYARIKAT - hardcode if certain patterns are found
  if (result['SYARIKAT']!.isEmpty && 
      rawLines.any((line) => line.contains('PENERIMAAN BTS FELDA/FPSB/FTP/FASSB'))) {
    result['SYARIKAT'] = 'FELDA JENGKA 4';
    print("Extracted SYARIKAT with fallback: ${result['SYARIKAT']}");
  }
  
  // For Trailer Number (usually starts with T/A)
  if (result['NOMBOR TRAILER']!.isEmpty) {
    for (String line in rawLines) {
      if (line.contains('T/A') || RegExp(r'T/[A-Z][0-9]{3,5}').hasMatch(line)) {
        String match = RegExp(r'T/[A-Z][0-9]{3,5}').stringMatch(line) ?? line.trim();
        result['NOMBOR TRAILER'] = match;
        print("Extracted trailer number: ${result['NOMBOR TRAILER']}");
        break;
      }
    }
  }
  
  // For Delivery Note (usually a numeric value)
  if (result['NOTA HANTARAN/ARAHAN ANGKUT']!.isEmpty) {
    for (String line in rawLines) {
      if (line.contains('NOTA') || line.contains('ARAHAN') || line.contains('HANTARAN')) {
        // Look for number after the field name
        if (line.contains(':')) {
          int colonPos = line.indexOf(':');
          String value = line.substring(colonPos + 1).trim();
          if (value.isNotEmpty && RegExp(r'^\d+$').hasMatch(value)) {
            result['NOTA HANTARAN/ARAHAN ANGKUT'] = value;
            print("Extracted delivery note: ${result['NOTA HANTARAN/ARAHAN ANGKUT']}");
            break;
          }
        }
      }
    }
  }
  
  // If still empty, look for numeric values that could be delivery notes
  if (result['NOTA HANTARAN/ARAHAN ANGKUT']!.isEmpty) {
    for (String line in rawLines) {
      if (RegExp(r'^\d{4}$').hasMatch(line.trim())) {  // Looking for a 4-digit number
        result['NOTA HANTARAN/ARAHAN ANGKUT'] = line.trim();
        print("Extracted delivery note from numeric pattern: ${result['NOTA HANTARAN/ARAHAN ANGKUT']}");
        break;
      }
    }
  }
  
  // Extract date and time fields
  // For Entry Date (format: DD/MM/YYYY)
  if (result['TARIKH MASUK']!.isEmpty) {
    for (String line in rawLines) {
      if (line.toUpperCase().contains('TARIKH MASUK')) {
        if (line.contains(':')) {
          int colonPos = line.indexOf(':');
          String value = line.substring(colonPos + 1).trim();
          
          // Look for date pattern
          if (RegExp(r'\d{2}/\d{2}/\d{4}').hasMatch(value)) {
            result['TARIKH MASUK'] = RegExp(r'\d{2}/\d{2}/\d{4}').stringMatch(value)!;
            print("Extracted TARIKH MASUK: ${result['TARIKH MASUK']}");
          } else if (value.isNotEmpty) {
            result['TARIKH MASUK'] = value;
            print("Extracted TARIKH MASUK (raw): ${result['TARIKH MASUK']}");
          }
        }
      } else if (RegExp(r'\d{2}/\d{2}/\d{4}').hasMatch(line)) {
        // Look for standalone date pattern
        String date = RegExp(r'\d{2}/\d{2}/\d{4}').stringMatch(line)!;
        
        // Check if this is likely an entry date (not an exit date)
        if (!line.toUpperCase().contains('KELUAR')) {
          result['TARIKH MASUK'] = date;
          print("Extracted TARIKH MASUK from standalone pattern: ${result['TARIKH MASUK']}");
        }
      }
    }
  }
  
  // For Entry Time (format: HH:MM:SS)
  if (result['MASA MASUK']!.isEmpty) {
    for (String line in rawLines) {
      if (line.toUpperCase().contains('MASA MASUK')) {
        if (line.contains(':')) {
          // Find the last colon which is likely after the field name
          int lastColonPos = line.lastIndexOf(':');
          if (lastColonPos > line.toUpperCase().indexOf('MASA MASUK')) {
            String value = line.substring(lastColonPos + 1).trim();
            
            // Check if this looks like a time
            if (RegExp(r'\d{2}:\d{2}:\d{2}').hasMatch(value) || 
                RegExp(r'\d{2}:\d{2}').hasMatch(value)) {
              result['MASA MASUK'] = value;
              print("Extracted MASA MASUK: ${result['MASA MASUK']}");
            } else if (value.isNotEmpty) {
              result['MASA MASUK'] = value;
              print("Extracted MASA MASUK (raw): ${result['MASA MASUK']}");
            }
          } else {
            // Check if there's a time pattern in the line
            if (RegExp(r'\d{2}:\d{2}:\d{2}').hasMatch(line)) {
              result['MASA MASUK'] = RegExp(r'\d{2}:\d{2}:\d{2}').stringMatch(line)!;
              print("Extracted MASA MASUK from full line: ${result['MASA MASUK']}");
            }
          }
        }
      } else if (line.contains(':') && 
                 RegExp(r'\d{2}:\d{2}:\d{2}').hasMatch(line) && 
                 !line.toUpperCase().contains('TEL') && 
                 !line.toUpperCase().contains('FAX') &&
                 !line.toUpperCase().contains('KELUAR')) {
        // Find standalone time pattern that might be entry time
        result['MASA MASUK'] = RegExp(r'\d{2}:\d{2}:\d{2}').stringMatch(line)!;
        print("Extracted MASA MASUK from standalone pattern: ${result['MASA MASUK']}");
      }
    }
  }
  
  // Print summary of extraction results
  print("===== KEY FIELD EXTRACTION SUMMARY =====");
  keyFieldMappings.keys.forEach((key) {
    print("$key: ${result[key] == '' ? '(not found)' : result[key]}");
  });
  
  return result;
}

 void _processExtractedText(String text) {
  final List<String> rawLines = text
      .split('\n')
      .map((line) => line.trim())
      .where((line) => line.isNotEmpty)
      .toList();

  // Print raw lines for debugging
  print("==== RAW OCR TEXT LINES ====");
  for (int i = 0; i < rawLines.length; i++) {
    print('[${i}] ${rawLines[i]}');
  }

  // Extract basic document information
  String? companyName;
  List<String> locationLines = [];
  String? contactInfo;
  String? gatePassTitle;
  
  // Look for company name (usually in the first few lines)
  for (int i = 0; i < min(5, rawLines.length); i++) {
    if (rawLines[i].contains('FGV') || rawLines[i].contains('Palm Industries')) {
      companyName = rawLines[i];
      break;
    }
  }
  
  // Extract location information (usually contains PUSAT, FELDA, MARAN, PAHANG)
  for (String line in rawLines) {
    if (line.contains('PUSAT') || 
        line.contains('FELDA') || 
        line.contains('MARAN') || 
        line.contains('PAHANG') ||
        line.contains('D/A')) {
      if (!line.contains(':') && 
          !line.contains('NOMBOR') && 
          !line.contains('HANTARAN')) {
        locationLines.add(line);
      }
    }
  }
  
  // Extract contact information (contains Tel or Fax)
  for (String line in rawLines) {
    if (line.contains('Tel') || line.contains('Fax')) {
      contactInfo = line;
      break;
    }
  }
  
  // Extract gate pass title
  for (String line in rawLines) {
    if (line.contains('GATEPASS') || 
        line.contains('GATE PASS') || 
        line.contains('G A T E P A S S') ||
        line.contains('GAT EPA SS')) {
      gatePassTitle = line;
      break;
    }
  }

  // Use enhanced extraction for key fields
  Map<String, String> keyFields = extractKeyFields(rawLines);

  print("=== SYARIKAT FIELD DEBUG ===");
  print("Final extracted SYARIKAT: ${keyFields['SYARIKAT']}");
  
  // Process additional fields for completeness
  Map<String, String> additionalFields = {
    "MUDA": "",
    "(P/T)": "",
    "LAMA": "",
    "PERAM": "",
    "DURA": "",
    "MENGKAL": "",
    "KOSONG": "",
    "PANJANG": "",
    "BUSUK": "",
    "KOTOR": "",
    "S/TIKUS": "",
    "B/A": ""
  };
  
  // Check for additional fields in the document
  for (String line in rawLines) {
    for (String key in additionalFields.keys.toList()) {
      if (line.contains(key)) {
        // Try to extract value if it has one
        int keyIndex = line.indexOf(key);
        if (keyIndex + key.length < line.length) {
          String rest = line.substring(keyIndex + key.length).trim();
          if (rest.startsWith(':')) {
            String value = rest.substring(1).trim();
            if (value.isNotEmpty) {
              additionalFields[key] = value;
            }
          }
        }
      }
    }
  }
  
  // Create formatted output text similar to the image
  List<String> output = [];
  
  // Add header info
  if (gatePassTitle != null) {
    output.add(gatePassTitle);
  } else {
    output.add("GATEPASS");
  }
  
  for (String line in locationLines) {
    output.add(line);
  }
  
  if (contactInfo != null) {
    output.add(contactInfo);
  }
  
  // Add divider that shows in the image
  output.add("PENERIMAAN BTS FELDA/FPSB/FTP/FASSB");
  output.add("-".padRight(60, '-'));
  
  // Add the key fields in the specified order
  output.add("NOMBOR KENDERAAN: ${keyFields['NOMBOR KENDERAAN']}");
  output.add("K.P. PEMANDU: ${keyFields['K.P. PEMANDU']}");
  output.add("NAMA PEMANDU: ${keyFields['NAMA PEMANDU']}");
  output.add("SYARIKAT: ${keyFields['SYARIKAT']}");
  output.add("NOMBOR TRAILER: ${keyFields['NOMBOR TRAILER']}");
  output.add("NOTA HANTARAN/ARAHAN ANGKUT: ${keyFields['NOTA HANTARAN/ARAHAN ANGKUT']}");
  
  // Extract and add dates and times
  String entryDate = "", entryTime = "", exitDate = "", exitTime = "";
  
  // Look for entry date and time
  for (String line in rawLines) {
    if (line.toUpperCase().contains('TARIKH MASUK')) {
      if (line.contains(':')) {
        String value = line.substring(line.indexOf(':') + 1).trim();
        if (value.isNotEmpty) entryDate = value;
      }
    }
    if (line.toUpperCase().contains('MASA MASUK')) {
      if (line.contains(':')) {
        String value = line.substring(line.indexOf(':') + 1).trim();
        if (value.isNotEmpty) entryTime = value;
      }
    }
  }
  
  output.add("TARIKH MASUK: $entryDate");
  output.add("MASA MASUK: $entryTime");
  output.add("TARIKH KELUAR: $exitDate");
  output.add("MASA KELUAR: $exitTime");
  
  // Add additional fields
  var addFields = [
    'MUDA', '(P/T)', 'LAMA',
    'PERAM', '(P/T)', 'DURA',
    'MENGKAL', 'KOSONG', 'PANJANG',
    'BUSUK', 'KOTOR', 'S/TIKUS', 'B/A'
  ];
  
  for (String field in addFields) {
    output.add("$field: ${additionalFields[field]}");
  }
  
  // Create DocumentData object with the extracted information
  _documentData = DocumentData(
    companyName: companyName,
    location: locationLines.join('\n'),
    contactInfo: contactInfo,
    vehicleNumber: keyFields['NOMBOR KENDERAAN'],
    driverIc: keyFields['K.P. PEMANDU'],
    driverName: keyFields['NAMA PEMANDU'], 
    company: keyFields['SYARIKAT'],
    trailerNumber: keyFields['NOMBOR TRAILER'],
    deliveryNote: keyFields['NOTA HANTARAN/ARAHAN ANGKUT'],
    entryDate: entryDate,
    entryTime: entryTime,
    exitDate: exitDate,
    exitTime: exitTime,
    additionalFields: additionalFields,
  );
  
  setState(() {
    _extractedText = output.join('\n');
  });
  
  // Debug: Print formatted output
  print("==== FORMATTED OUTPUT ====");
  output.forEach((line) => print(line));
}

  void _copyToClipboard() {
    if (_extractedText != null && _extractedText!.isNotEmpty) {
      Clipboard.setData(ClipboardData(text: _extractedText!));
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Text copied to clipboard')),
      );
    }
  }

  Future<void> _saveAsJson() async {
  if (_documentData == null) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('No data to save')),
    );
    return;
  }
  
  // Convert the document data to a JSON map
  final jsonMap = _documentData!.toJson();
  
  // Convert to a prettified JSON string for display in debug console
  final JsonEncoder encoder = JsonEncoder.withIndent('  ');
  final String prettyJson = encoder.convert(jsonMap);
  
  // Print the JSON to the debug console
  print("==== DOCUMENT JSON DATA ====");
  print(prettyJson);
  
  // Create JSON string for saving
  final jsonString = jsonEncode(jsonMap);
  
  // Get the temporary directory
  final directory = await getTemporaryDirectory();
  final timestamp = DateTime.now().millisecondsSinceEpoch;
  final fileName = 'document_data_$timestamp.json';
  final filePath = '${directory.path}/$fileName';
  
  // Write the JSON to a file
  final file = File(filePath);
  await file.writeAsString(jsonString, flush: true);
  
  // Share the file
  await Share.shareXFiles(
    [XFile(filePath)],
    text: 'Document Data JSON',
  );
  
  ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(content: Text('JSON file created and shared')),
  );
}

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
        actions: [
          if (_extractedText != null && _extractedText!.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.copy),
              onPressed: _copyToClipboard,
              tooltip: 'Copy text',
            ),
          if (_documentData != null)
            IconButton(
              icon: const Icon(Icons.save_alt),
              onPressed: _saveAsJson,
              tooltip: 'Save as JSON',
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Center(
                  child: SizedBox(
                    width: 180, // adjust width as needed
                    height: 45, // adjust height as needed
                    child: ElevatedButton.icon(
                      onPressed: _pickImage,
                      icon: const Icon(Icons.document_scanner),
                      label: const Text('Scan Document'),
                      style: ElevatedButton.styleFrom(
                        textStyle: const TextStyle(fontSize: 14),
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            if (_file != null && _isImage)
              Container(
                margin: const EdgeInsets.only(bottom: 16),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey.shade400),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    ClipRRect(
                      borderRadius: const BorderRadius.vertical(top: Radius.circular(8)),
                      child: Image.file(_file!, fit: BoxFit.cover),
                    ),
                    Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: Text(
                        'File: $_fileName',
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 14,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            
            if (_file != null && !_isImage)
              Card(
                margin: const EdgeInsets.only(bottom: 16),
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Row(
                    children: [
                      const Icon(Icons.picture_as_pdf, size: 28, color: Colors.red),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          'File: $_fileName',
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: 14,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            
            if (_isProcessing)
              const Center(
                child: Column(
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 16),
                    Text("Processing document..."),
                  ],
                ),
              )
            else ...[
              const Text(
                "Extracted Text:", 
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  border: Border.all(color: Colors.grey.shade400),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: SelectableText(
                  _extractedText ?? 'No text extracted yet. Scan a document.',
                  style: const TextStyle(fontSize: 15, height: 1.5),
                ),
              ),
            ],
          ],
        ),
      ),
      floatingActionButton: _extractedText != null && _extractedText!.isNotEmpty
        ? Column(
          mainAxisAlignment: MainAxisAlignment.end,
          mainAxisSize: MainAxisSize.min,
          children: [
            FloatingActionButton(
              onPressed: _copyToClipboard,
              tooltip: 'Copy Text',
              heroTag: 'copy',
              child: const Icon(Icons.content_copy),
            ),
            const SizedBox(height: 16),
            FloatingActionButton(
              onPressed: _saveAsJson,
              tooltip: 'Save as JSON',
              heroTag: 'json',
              backgroundColor: Colors.green,
              child: const Icon(Icons.code),
            ),
          ],
        )
      : null,
    );
  }
}

// Helper function
int min(int a, int b) => a < b ? a : b;

// Helper function to check if a string contains any field name
bool containsAnyFieldName(String text, Map<String, List<String>> fieldMappings) {
  for (List<String> fieldNames in fieldMappings.values) {
    for (String fieldName in fieldNames) {
      if (text.toUpperCase().contains(fieldName.toUpperCase())) {
        return true;
      }
    }
  }
  return false;
}